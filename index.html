<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>WEB IPTV — Cutie Enhanced</title>

<!-- Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/hls.js/1.4.0/hls.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/shaka-player/4.3.6/shaka-player.compiled.min.js"></script>

<!-- your channels file (unchanged) -->
<script src="channels.js"></script>

<link rel="icon" href="logo.png" type="image/png" />

<style>
  :root{
    --bg:#0f0f10;
    --panel:#18191a;
    --muted:#9a9a9a;
    --accent:#ff3ea6;
    --glass: rgba(255,255,255,0.03);
    --card: #1f1f20;
  }
  *{box-sizing:border-box;font-family:Inter, system-ui, Arial, sans-serif}
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#0b0b0c 0%, #121214 100%);color:#fff}
  .app{
    display:grid;
    grid-template-columns:260px 1fr;
    height:100vh;
    gap:18px;
    padding:18px;
  }

  /* Sidebar */
  .sidebar{
    background:var(--panel);
    border-radius:12px;
    padding:14px;
    display:flex;
    flex-direction:column;
    gap:12px;
    box-shadow:0 6px 18px rgba(0,0,0,0.6);
    overflow:auto;
  }

  .topbar{
    grid-column:1 / -1;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
    position:sticky;
    top:0;
    z-index:30;
    margin-bottom:6px;
  }

  .logo{
    display:flex;
    align-items:center;
    gap:10px;
  }

  .logo img{width:44px;height:44px;border-radius:50%;object-fit:cover}
  .title{
    font-weight:700;font-size:18px;letter-spacing:0.2px;
  }

  .controls{
    display:flex;gap:8px;align-items:center;
  }

  /* Search / filter */
  .searchBox{
    display:flex;gap:8px;
    background:var(--glass);
    padding:8px;border-radius:10px;align-items:center;
  }
  .searchBox input{
    background:transparent;border:0;color:#fff;outline:none;font-size:14px;width:100%;
  }
  .select{
    background:transparent;border:1px solid rgba(255,255,255,0.06);padding:6px 8px;border-radius:8px;color:var(--muted);
  }

  /* Channel lists */
  .sectionTitle{font-size:13px;color:var(--muted);margin-top:4px;margin-bottom:6px}
  .channelList{display:flex;flex-direction:column;gap:8px;padding-bottom:20px}
  .channelCard{
    display:flex;align-items:center;gap:10px;padding:10px;border-radius:10px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);cursor:pointer;
    transition:transform .12s, box-shadow .12s, background .12s; border:1px solid rgba(255,255,255,0.03);
  }
  .channelCard:hover{transform:translateY(-4px);box-shadow:0 8px 24px rgba(0,0,0,0.6)}
  .chThumb{width:46px;height:32px;background:#111;border-radius:6px;flex-shrink:0;display:flex;align-items:center;justify-content:center;color:var(--muted);font-size:12px}
  .chInfo{flex:1}
  .chName{font-weight:600;font-size:14px}
  .chType{font-size:12px;color:var(--muted);margin-top:2px}

  .favBtn{width:28px;height:28px;border-radius:8px;border:0;background:transparent;cursor:pointer;display:flex;align-items:center;justify-content:center}
  .favBtn svg{opacity:.85}

  /* Main area */
  .main{
    display:flex;flex-direction:column;gap:12px;
    overflow:auto;padding-bottom:12px;
  }

  .playerCard{
    background:var(--card);border-radius:12px;padding:12px;border:1px solid rgba(255,255,255,0.04);
    display:flex;flex-direction:column;gap:10px;align-items:center;justify-content:center;min-height:360px;
  }

  .videoWrap{width:100%;display:flex;align-items:center;justify-content:center;min-height:300px}
  video, iframe{width:90%;max-width:1100px;border-radius:8px;background:#000;display:none;border:1px solid rgba(255,255,255,0.04)}
  #shakaContainer{display:none;width:100%;justify-content:center}

  .nowPlaying{
    display:flex;align-items:center;gap:10px;width:100%;padding:8px;border-radius:10px;background:linear-gradient(90deg, rgba(255,255,255,0.02), transparent);
  }
  .nowName{font-weight:700}
  .nowSmall{font-size:13px;color:var(--muted)}

  /* overlays */
  .overlay{
    position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);z-index:120;
    background:rgba(0,0,0,0.6);padding:16px;border-radius:10px;display:flex;align-items:center;gap:10px;color:#fff
  }

  .spinner{
    width:22px;height:22px;border-radius:50%;border:3px solid rgba(255,255,255,0.08);border-top-color:var(--accent);animation:spin 1s linear infinite
  }
  @keyframes spin{to{transform:rotate(360deg)}}

  .muted{color:var(--muted)}

  /* responsive */
  @media (max-width:900px){
    .app{grid-template-columns:1fr;grid-auto-rows:auto;padding:10px}
    .sidebar{order:2}
    .main{order:1}
    .logo img{width:36px;height:36px}
  }
</style>
</head>
<body>
  <div class="topbar" style="padding:0 18px 8px 18px;">
    <div class="logo">
      <img src="mwlogo.png" alt="logo" onerror="this.style.display='none'"/>
      <div>
        <div class="title">WEB IPTV — Cutie</div>
        <div class="muted" style="font-size:12px">HLS • DASH • YouTube</div>
      </div>
    </div>

    <div class="controls">
      <div class="searchBox" style="min-width:260px;max-width:420px">
        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" style="opacity:.6" viewBox="0 0 16 16"><path d="M11 6a5 5 0 1 1-1-9.9A5 5 0 0 1 11 6zm-1.5 6.5L14 16l.5-.5-4.5-4.5"/><path fill="none"/></svg>
        <input id="searchInput" placeholder="Search channels..." />
      </div>

      <select id="typeFilter" class="select">
        <option value="all">All</option>
        <option value="hls">HLS</option>
        <option value="dash">DASH</option>
        <option value="youtube">YouTube</option>
      </select>
    </div>
  </div>

  <div class="app">
    <aside class="sidebar">
      <div>
        <div class="sectionTitle">Favorites</div>
        <div id="favoritesList" class="channelList"></div>
      </div>

      <div style="margin-top:6px">
        <div class="sectionTitle">All Channels</div>
        <div id="channelsList" class="channelList"></div>
      </div>
    </aside>

    <main class="main">
      <div class="playerCard" id="playerCard" style="position:relative">
        <div class="nowPlaying" id="nowPlaying" style="display:none">
          <div class="chThumb" id="nowThumb">TV</div>
          <div style="flex:1">
            <div class="nowName" id="nowTitle">Not playing</div>
            <div class="nowSmall" id="nowType">—</div>
          </div>
          <div id="nowControls" style="display:flex;gap:8px;align-items:center">
            <div id="loadingIndicator" style="display:none" class="muted">
              <span class="spinner"></span> <span style="margin-left:8px">Loading…</span>
            </div>
          </div>
        </div>

        <div class="videoWrap">
          <iframe id="videoFrame" width="1280" height="720" frameborder="0" allowfullscreen></iframe>
          <video id="videoPlayer" controls playsinline></video>
        </div>

        <div id="shakaContainer">
          <video id="shakaPlayer" controls autoplay playsinline></video>
        </div>

        <!-- reconnect overlay -->
        <div id="reconnectOverlay" class="overlay" style="display:none">
          <div class="spinner"></div>
          <div>Reconnecting…</div>
        </div>
      </div>

      <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
        <div class="muted">Tip: Click ⭐ to add favorites • Search filters list live</div>
      </div>
    </main>
  </div>

<script>
/* === Core players & state === */
const video = document.getElementById('videoPlayer');
const iframe = document.getElementById('videoFrame');
let hls = null;

const shakaVideo = document.getElementById('shakaPlayer');
const shakaContainer = document.getElementById('shakaContainer');
let shakaPlayer = new shaka.Player(shakaVideo);

/* UI nodes */
const channelsList = document.getElementById('channelsList');
const favoritesList = document.getElementById('favoritesList');
const searchInput = document.getElementById('searchInput');
const typeFilter = document.getElementById('typeFilter');
const nowPlaying = document.getElementById('nowPlaying');
const nowTitle = document.getElementById('nowTitle');
const nowType = document.getElementById('nowType');
const nowThumb = document.getElementById('nowThumb');
const loadingIndicator = document.getElementById('loadingIndicator');
const reconnectOverlay = document.getElementById('reconnectOverlay');
const playerCard = document.getElementById('playerCard');

/* state */
let favorites = JSON.parse(localStorage.getItem('iptv_favs') || '[]');
let lastPlayedName = localStorage.getItem('iptv_last') || null;
let currentChannel = null;
let reconnecting = false;
let reconnectAttempts = 0;
let freezeWatcher = null;

/* ensure shaka polyfills installed */
(async ()=>{ await shaka.polyfill.installAll(); if (!shaka.Player.isBrowserSupported()) console.warn('Shaka not fully supported'); })();

/* Helper: render a channel card node */
function makeChannelCard(channel){
  const card = document.createElement('div');
  card.className = 'channelCard';
  const thumb = document.createElement('div'); thumb.className='chThumb';
  thumb.textContent = channel.name.split(' ')[0].slice(0,6);
  const info = document.createElement('div'); info.className='chInfo';
  const n = document.createElement('div'); n.className='chName'; n.textContent = channel.name;
  const t = document.createElement('div'); t.className='chType'; t.textContent = channel.type.toUpperCase();
  info.appendChild(n); info.appendChild(t);

  const favBtn = document.createElement('button'); favBtn.className='favBtn';
  favBtn.innerHTML = isFav(channel) ? starSVG(true) : starSVG(false);
  favBtn.title = isFav(channel) ? 'Remove favorite' : 'Add to favorites';
  favBtn.addEventListener('click', (e)=>{
    e.stopPropagation();
    toggleFav(channel);
    renderLists();
  });

  card.appendChild(thumb);
  card.appendChild(info);
  card.appendChild(favBtn);

  card.addEventListener('click', ()=> playChannel(channel));
  return card;
}

/* star icon */
function starSVG(active){
  if(active) return `<svg width="18" height="18" viewBox="0 0 24 24" fill="${'#ffcc00'}" xmlns="http://www.w3.org/2000/svg"><path d="M12 17.3l6.18 3.73-1.64-7.03L21 9.24l-7.19-.61L12 2 10.19 8.63 3 9.24l4.46 4.76L5.82 21z"/></svg>`;
  return `<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.4" xmlns="http://www.w3.org/2000/svg"><path d="M12 17.3l6.18 3.73-1.64-7.03L21 9.24l-7.19-.61L12 2 10.19 8.63 3 9.24l4.46 4.76L5.82 21z" /></svg>`;
}

/* favorites helpers */
function isFav(ch){ return favorites.includes(ch.name); }
function toggleFav(ch){
  if(isFav(ch)) favorites = favorites.filter(n => n !== ch.name);
  else favorites.push(ch.name);
  localStorage.setItem('iptv_favs', JSON.stringify(favorites));
}

/* render lists with filters */
function renderLists(){
  const q = (searchInput.value || '').toLowerCase();
  const type = typeFilter.value;

  // favorites list
  favoritesList.innerHTML = '';
  const favChannels = combinedChannels.filter(ch => favorites.includes(ch.name));
  if(favChannels.length === 0){
    const p = document.createElement('div'); p.className='muted'; p.textContent='No favorites yet';
    favoritesList.appendChild(p);
  } else {
    favChannels.forEach(ch => favoritesList.appendChild(makeChannelCard(ch)));
  }

  // all channels
  channelsList.innerHTML = '';
  combinedChannels.filter(ch=>{
    if(type !== 'all' && ch.type !== type) return false;
    if(q && !ch.name.toLowerCase().includes(q)) return false;
    return true;
  }).forEach(ch => channelsList.appendChild(makeChannelCard(ch)));
}

/* play/stop management (keeps original behavior but extends) */
function stopAllPlayers(){
  // stop HLS
  if(hls){ try{ hls.destroy(); }catch(e){} hls=null; }
  // stop html5 video
  try{ video.pause(); video.removeAttribute('src'); video.load(); }catch(e){}
  // stop iframe
  try{ iframe.src = ''; }catch(e){}
  // shaka unload
  if(shakaPlayer){ shakaPlayer.unload().catch(()=>{}); }
  // hide displays
  video.style.display = 'none';
  iframe.style.display = 'none';
  shakaContainer.style.display = 'none';
  hideLoading();
  stopFreezeWatcher();
}

/* show/hide loading indicator */
function showLoading(){ loadingIndicator.style.display = 'flex'; }
function hideLoading(){ loadingIndicator.style.display = 'none'; }

/* set Now Playing UI */
function setNowPlaying(ch){
  currentChannel = ch;
  nowPlaying.style.display = 'flex';
  nowTitle.textContent = ch.name;
  nowType.textContent = ch.type.toUpperCase();
  nowThumb.textContent = ch.name.split(' ')[0].slice(0,6);
  localStorage.setItem('iptv_last', ch.name);
}

/* Play a channel (preserves your original logic) */
async function playChannel(channel){
  reconnecting = false; reconnectAttempts = 0; stopFreezeWatcher();
  stopAllPlayers();
  setNowPlaying(channel);
  showLoading();

  if(channel.type === 'youtube'){
    iframe.style.display = 'block';
    iframe.src = channel.url.replace('autoplay=1','autoplay=0');
    hideLoading();
    startFreezeWatcher(channel); // YouTube freeze detection not implemented (iframe limited), but included for consistency
    return;
  }

  if(channel.type === 'hls'){
    video.style.display = 'block';
    // init Hls
    if(Hls.isSupported()){
      hls = new Hls();
      hls.loadSource(channel.url);
      hls.attachMedia(video);
      hls.on(Hls.Events.MANIFEST_PARSED, ()=>{ video.play().catch(()=>{}); hideLoading(); startFreezeWatcher(channel); });
      hls.on(Hls.Events.ERROR,(evt,data)=>{
        console.warn('HLS error',data);
        if(data && data.fatal) attemptReconnect(channel);
      });
    } else if(video.canPlayType('application/vnd.apple.mpegurl')){
      video.src = channel.url;
      video.play().then(()=>{}).catch(()=>{});
      hideLoading();
      startFreezeWatcher(channel);
    } else {
      hideLoading();
      alert('HLS not supported on this browser');
    }
    return;
  }

  if(channel.type === 'dash' || channel.type === 'clearkey'){
    shakaContainer.style.display = 'flex';
    shakaVideo.style.display = 'block';
    try {
      if(channel.clearKey){
        shakaPlayer.configure({ drm: { clearKeys: channel.clearKey } });
      } else {
        // leave default
      }
      shakaPlayer.configure({
        streaming: { bufferingGoal: 60, rebufferingGoal: 2, bufferBehind: 30 },
        abr: { enabled: true, defaultBandwidthEstimate: 500000 }
      });
      await shakaPlayer.load(channel.url);
      shakaVideo.play().catch(()=>{});
      hideLoading();
      startFreezeWatcher(channel);
      // Shaka player error handling
      shakaPlayer.removeEventListener('error', onShakaError);
      shakaPlayer.addEventListener('error', onShakaError);
    } catch(err){
      console.error('Shaka failed to load', err);
      hideLoading();
      attemptReconnect(channel);
    }
    return;
  }
}

/* Shaka error handler */
function onShakaError(event){
  console.error('Shaka player error', event);
  if(event && event.detail) attemptReconnect(currentChannel);
}

/* === Smart freeze detection & reconnect ===
 - Mechanism:
   * Periodically sample player's currentTime (every 3s).
   * If time hasn't advanced for N samples (approx 9s) while player is not paused and readyState>0, consider it stuck.
   * Show reconnect overlay and attempt to reload source (HLS: destroy & re-init; DASH: shaka unload/load).
   * Retry indefinitely until success. (infinite loop behavior requested)
*/
function startFreezeWatcher(channel){
  stopFreezeWatcher();
  let lastTime = -1;
  let stuckCount = 0;
  const sampleInterval = 3000; // ms
  const allowedStuckSamples = 3; // ~9s of no progress

  freezeWatcher = setInterval(async ()=>{
    // If user intentionally paused, do nothing
    if(channel.type === 'youtube'){
      // iframe can't inspect currentTime reliably; skip aggressive reconnects
      return;
    }

    let curTime = null;
    let paused = false;
    let ready = 0;

    if(channel.type === 'hls'){
      try{ curTime = video.currentTime; paused = video.paused; ready = video.readyState; }catch(e){}
    } else if(channel.type === 'dash' || channel.type === 'clearkey'){
      try{ curTime = shakaVideo.currentTime; paused = shakaVideo.paused; ready = shakaVideo.readyState; }catch(e){}
    }

    // if not playing (paused) or not enough buffer/ready, don't count as frozen
    if(paused || ready === 0 || curTime === 0){ lastTime = curTime; stuckCount = 0; return; }

    if(lastTime === curTime){
      stuckCount++;
    } else {
      stuckCount = 0;
      lastTime = curTime;
      // on successful progress during reconnecting -> hide overlay & reset attempts
      if(reconnecting){
        reconnecting = false;
        reconnectAttempts = 0;
        reconnectOverlay.style.display = 'none';
      }
    }

    if(stuckCount >= allowedStuckSamples){
      console.warn('Playback appears stuck — attempting reconnect', {channel: channel.name});
      attemptReconnect(channel);
      stuckCount = 0;
      lastTime = -1;
    }

  }, sampleInterval);
}

function stopFreezeWatcher(){
  if(freezeWatcher){ clearInterval(freezeWatcher); freezeWatcher = null; }
}

/* Attempt reconnect logic (infinite retry until success) */
async function attemptReconnect(channel){
  if(!channel) return;
  reconnecting = true;
  reconnectOverlay.style.display = 'flex';
  reconnectAttempts++;
  showLoading();

  // small backoff to avoid instant hot loops
  const backoff = Math.min(5000 + reconnectAttempts * 1000, 20000);
  await new Promise(r => setTimeout(r, backoff));

  try {
    if(channel.type === 'hls'){
      // destroy and reinit
      if(hls){ try{ hls.destroy(); }catch(e){} hls = null; }
      video.pause(); video.removeAttribute('src'); video.load();
      hls = new Hls();
      hls.loadSource(channel.url);
      hls.attachMedia(video);
      // reattach events
      hls.on(Hls.Events.MANIFEST_PARSED, ()=>{
        video.play().catch(()=>{});
      });
      hls.on(Hls.Events.ERROR,(evt,data)=>{
        if(data && data.fatal) console.warn('HLS reconnect fatal',data);
      });
      // wait shortly and check if resumed
      await waitForPlaybackProgress(video, 10000);
    } else if(channel.type === 'dash' || channel.type === 'clearkey'){
      // use shaka to reload
      try{ await shakaPlayer.unload(); }catch(e){}
      if(channel.clearKey){
        shakaPlayer.configure({ drm: { clearKeys: channel.clearKey } });
      }
      await shakaPlayer.load(channel.url);
      shakaVideo.play().catch(()=>{});
      await waitForPlaybackProgress(shakaVideo, 10000);
    } else {
      // nothing to do for youtube iframe — give up here
      reconnectOverlay.style.display = 'none';
      hideLoading();
      reconnecting = false;
      return;
    }

    // if reached here without throw, we assume playback resumed
    reconnecting = false;
    reconnectAttempts = 0;
    reconnectOverlay.style.display = 'none';
    hideLoading();
    startFreezeWatcher(channel);
    console.info('Reconnected successfully to', channel.name);
  } catch (err){
    console.warn('Reconnect attempt failed:', err);
    // try again (infinite)
    attemptReconnect(channel);
  }
}

/* waitForPlaybackProgress: resolves if currentTime advances within timeout; rejects otherwise */
function waitForPlaybackProgress(playerEl, timeout = 8000){
  return new Promise((resolve, reject)=>{
    const startTime = playerEl.currentTime || 0;
    const start = Date.now();
    const check = setInterval(()=>{
      if((playerEl.currentTime || 0) > startTime + 0.1){
        clearInterval(check); resolve(true);
      } else if(Date.now() - start > timeout){
        clearInterval(check); reject(new Error('no-progress'));
      }
    }, 700);
  });
}

/* initial render + event wiring */
function initUI(){
  renderLists();
  // wire search + filter
  searchInput.addEventListener('input', ()=>renderLists());
  typeFilter.addEventListener('change', ()=>renderLists());

  // auto-play last channel if present
  if(lastPlayedName){
    const ch = combinedChannels.find(c => c.name === lastPlayedName);
    if(ch) setTimeout(()=>playChannel(ch), 700);
  }
}

/* expose some debug helpers */
window.ipvtools = {
  playByName: (name)=> {
    const ch = combinedChannels.find(c=>c.name===name);
    if(ch) playChannel(ch);
  },
  stop: stopAllPlayers
};

/* start */
document.addEventListener('DOMContentLoaded', ()=> {
  initUI();
});

</script>
</body>
</html>
