<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mixed IPTV Player â€” HLS / DASH / MP4</title>

<!-- HLS.js -->
<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<!-- dash.js -->
<script src="https://cdn.dashjs.org/latest/dash.all.min.js"></script>

<style>
  :root{--bg:#07111a;--card:#0f1f29;--muted:#9fb3bf;--accent:#00d1ff}
  body{margin:0; font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial; background:linear-gradient(180deg,#07111a 0%, #021018 100%); color:#e6f7fb}
  header{display:flex;align-items:center;gap:16px;padding:14px 18px;background:rgba(255,255,255,0.02);box-shadow:0 2px 8px rgba(0,0,0,0.3)}
  header h1{font-size:16px;margin:0}
  #playerWrap{padding:12px}
  video{width:100%;max-height:56vh;background:#000;border-radius:8px;box-shadow:0 6px 20px rgba(0,0,0,0.6)}
  #controlsRow{display:flex;gap:8px;align-items:center;margin-top:8px}
  button, input[type="search"]{background:var(--card);border:1px solid rgba(255,255,255,0.03);padding:8px 10px;border-radius:8px;color:var(--muted)}
  input[type="search"]{flex:1}
  #layout{display:grid; grid-template-columns: 360px 1fr; gap:12px; padding:12px}
  #sidebar{background:rgba(255,255,255,0.02); border-radius:8px;padding:10px; overflow:auto; max-height:70vh}
  .channel{padding:10px;border-radius:8px;margin-bottom:8px;background:linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.03));cursor:pointer;display:flex;align-items:center;gap:10px}
  .channel:hover{transform:translateY(-2px);box-shadow:0 8px 18px rgba(0,0,0,0.4)}
  .channel .title{font-size:13px;color:#e8fbff}
  .muted{color:var(--muted);font-size:12px}
  #nowPlaying{margin-top:10px;padding:10px;border-radius:8px;background:rgba(255,255,255,0.02)}
  .small{font-size:12px}
  #footer{padding:12px;text-align:center;color:var(--muted);font-size:13px}
  @media(max-width:900px){#layout{grid-template-columns:1fr; } #sidebar{max-height:32vh}}
</style>
</head>
<body>

<header>
  <img src="" alt="" style="width:36px;height:36px;border-radius:6px;background:linear-gradient(45deg,var(--accent),#7af1ff);display:inline-block">
  <h1>IPTV Mixed Player â€” HLS / DASH / MP4</h1>
  <div style="margin-left:auto" class="muted">Supports .m3u8, .mpd, .mp4 and some DRM via DASH</div>
</header>

<main id="playerWrap">
  <video id="video" controls playsinline webkit-playsinline></video>

  <div id="controlsRow">
    <input id="search" type="search" placeholder="Search channels..." />
    <button id="refreshBtn">ðŸ”„ Refresh Playlist</button>
    <button id="autoRefreshToggle">Auto Refresh: OFF</button>
    <label class="small muted" style="margin-left:8px">Auto reconnect on error</label>
  </div>

  <div id="layout">
    <!-- Sidebar: channel list -->
    <aside id="sidebar">
      <div style="display:flex;gap:8px;align-items:center;justify-content:space-between;margin-bottom:10px">
        <div class="muted small">Channels</div>
        <div class="muted small">Total: <span id="totalCount">0</span></div>
      </div>
      <div id="channelList"></div>
    </aside>

    <!-- Main panel -->
    <section id="mainPanel">
      <div id="nowPlaying">
        <div><strong id="nowTitle">No channel playing</strong></div>
        <div class="muted small" id="nowMeta">â€”</div>
      </div>

      <div style="margin-top:12px;padding:10px;background:rgba(255,255,255,0.01);border-radius:8px">
        <div class="muted small">Logs</div>
        <pre id="log" style="height:220px;overflow:auto;margin:0;padding:8px;background:transparent;border:0;color:var(--muted);font-size:12px"></pre>
      </div>
    </section>
  </div>

  <div id="footer">Tip: Streams requiring DRM or private license servers may not play unless the license server supports browser CORS and your device supports that DRM.</div>
</main>

<script>
/* ============================
   Configuration - set playlist URL
   ============================ */
const PLAYLIST_URL = "https://raw.githubusercontent.com/PRENDLYMADAPAKER/ANG-KALAT-MO/refs/heads/main/IPTV%20PREMIUM";

/* ============================
   Globals & Player instances
   ============================ */
let hlsInstance = null;
let dashPlayer = null;
let channels = [];
let autoRefresh = false;
let playlistAutoRefreshInterval = null;

/* Logging helper */
function log(...args){
  const el = document.getElementById('log');
  const t = new Date().toLocaleTimeString();
  el.textContent = `${t} â€” ${args.join(' ')}\n` + el.textContent;
}

/* Utility: robust parse for #KODIPROP style tags and #EXTINF */
function parseM3U(text){
  const lines = text.split(/\r?\n/).map(l => l.trim());
  const parsed = [];
  let meta = null;

  function parseKodipropFromStr(s){
    // Accept both: #KODIPROP:key=value key2="value 2"
    // We'll produce an object of key->value
    const out = {};
    // Remove leading #KODIPROP: if present
    const cleaned = s.replace(/^#KODIPROP:\s*/i, '');
    // Split by spaces but keep quoted strings together
    const parts = cleaned.match(/(?:[^\s"]+|"[^"]*")+/g) || [];
    for (let p of parts){
      const idx = p.indexOf('=');
      if (idx === -1) continue;
      const key = p.substring(0, idx).trim();
      let val = p.substring(idx+1).trim();
      if (val.startsWith('"') && val.endsWith('"')) val = val.slice(1,-1);
      out[key] = val;
    }
    return out;
  }

  for (let i=0;i<lines.length;i++){
    const l = lines[i];
    if (!l) continue;
    if (l.startsWith('#EXTINF')){
      meta = { raw: l, kodiprops: {} };
      // get channel name after comma
      const idx = l.indexOf(',');
      const name = idx >= 0 ? l.slice(idx+1).trim() : l;
      meta.name = name || 'Unknown';
    } else if (l.startsWith('#KODIPROP')){
      if (!meta) meta = { raw:'', kodiprops:{} };
      const obj = parseKodipropFromStr(l);
      meta.kodiprops = Object.assign(meta.kodiprops||{}, obj);
    } else if (l.startsWith('#')) {
      // ignore other tags
    } else if (l.startsWith('http') || l.startsWith('https')) {
      // stream url line
      const url = l;
      // Attach options passed inline in some playlists (like stream type)
      parsed.push({
        name: (meta && meta.name) || url,
        url,
        rawMeta: meta ? meta.raw : '',
        kodiprops: meta ? (meta.kodiprops || {}) : {}
      });
      meta = null;
    } else {
      // Could be relative path or other tokens - ignore for now
    }
  }
  return parsed;
}

/* ============================
   Playback helpers
   ============================ */
const videoEl = document.getElementById('video');

function destroyPlayers(){
  // destroy HLS
  if (hlsInstance){
    try { hlsInstance.destroy(); } catch(e){}
    hlsInstance = null;
  }
  // destroy DASH
  if (dashPlayer){
    try {
      dashPlayer.reset();
    } catch(e){}
    dashPlayer = null;
  }
  // Clear source
  try { videoEl.pause(); videoEl.removeAttribute('src'); videoEl.load(); } catch(e){}
}

function configureDashProtection(kodiprops, player){
  // This function inspects kodiprops for license info and maps to dash.js protection object.
  // Typical keys we might find: inputstream.adaptive.license_key, inputstream.adaptive.license_type
  // Example license_key value often looks like: "https://license.server/getlicense"
  const protection = {};
  const licKey = kodiprops['inputstream.adaptive.license_key'] || kodiprops['license_key'] || kodiprops['license_url'];
  const licType = (kodiprops['inputstream.adaptive.license_type'] || kodiprops['license_type'] || '').toLowerCase();

  if (!licKey) return null;

  // try guess system from license_type
  let system = null;
  if (licType.includes('widevine') || licType.includes('com.widevine.alpha')) system = 'com.widevine.alpha';
  else if (licType.includes('clearkey')) system = 'org.w3.clearkey';
  else {
    // If unknown, try widevine first then clearkey as fallback â€” but prefer explicit mapping if present
    system = 'com.widevine.alpha';
  }

  protection[system] = {
    serverURL: licKey
    // you can add headers or other fields here if needed; e.g.
    // httpRequestHeaders: { 'Authorization': 'Bearer xyz' }
  };

  // Some kodiprops embed headers or tokens inside license_key string with placeholders.
  // If you have custom formats, parse here.
  return protection;
}

function playChannel(ch){
  log('Starting channel:', ch.name, ch.url);
  document.getElementById('nowTitle').textContent = ch.name;
  document.getElementById('nowMeta').textContent = ch.url;

  destroyPlayers();

  // Basic type detection by url:
  const url = ch.url.split('?')[0].toLowerCase();
  if (url.endsWith('.m3u8') || ch.kodiprops['type'] === 'hls'){
    // HLS path
    if (Hls.isSupported()){
      hlsInstance = new Hls({enableWorker:true, maxBufferLength:30});
      hlsInstance.loadSource(ch.url);
      hlsInstance.attachMedia(videoEl);
      hlsInstance.on(Hls.Events.ERROR, (event, data) => {
        log('HLS error', data.type, data.details);
        if (data.fatal){
          if (data.type === 'networkError' || data.type === 'mediaError'){
            log('HLS fatal error -> try recover');
            try { hlsInstance.startLoad(); } catch(e){}
          } else {
            log('HLS fatal unrecoverable');
          }
        }
      });
    } else if (videoEl.canPlayType('application/vnd.apple.mpegurl')){
      videoEl.src = ch.url;
    } else {
      log('HLS not supported in this browser');
      alert('HLS not supported in your browser.');
    }
  } else if (url.endsWith('.mpd') || ch.kodiprops['type'] === 'dash'){
    // DASH path
    if (dashjs.MediaPlayer().isSupported()){
      dashPlayer = dashjs.MediaPlayer().create();
      // protection config
      const protection = configureDashProtection(ch.kodiprops || {}, dashPlayer);
      if (protection){
        log('DASH protection configured for manifest', JSON.stringify(protection));
        dashPlayer.getProtectionController().setProtectionData(protection);
      }
      dashPlayer.initialize(videoEl, ch.url, true);
      dashPlayer.on(dashjs.MediaPlayer.events.ERROR, (e) => {
        log('dash.js error', JSON.stringify(e));
      });
    } else {
      log('DASH not supported in this browser');
      alert('DASH not supported in your browser.');
    }
  } else {
    // fallback to direct source (mp4, ts, etc.)
    videoEl.src = ch.url;
  }

  // Try play and catch autoplay blocks
  const p = videoEl.play();
  if (p && p.catch) {
    p.catch(err => {
      log('Play rejected, user gesture required?', err && err.message ? err.message : err);
      // do not spam
    });
  }
  // Setup freeze detection & reconnect
  installFreezeDetection(videoEl, ch);
}

/* Freeze detection: if playback time doesn't increase for N seconds while not paused => try reconnect */
let freezeTimer = null;
function installFreezeDetection(video, ch){
  let lastTime = video.currentTime;
  let stuckCount = 0;

  // clear previous
  if (freezeTimer) { clearInterval(freezeTimer); freezeTimer = null; }
  freezeTimer = setInterval(() => {
    // if video is paused or ended, ignore
    if (video.paused || video.ended) { lastTime = video.currentTime; return; }
    const cur = video.currentTime;
    if (Math.abs(cur - lastTime) < 0.01){
      stuckCount++;
    } else {
      stuckCount = 0;
    }
    lastTime = cur;
    // if stuck for 8 checks (approx 8 seconds), attempt reload
    if (stuckCount >= 8){
      log('Playback appears stuck, attempting reconnect for', ch.name);
      // attempt reconnect: destroy & replay
      try {
        const oldUrl = ch.url;
        destroyPlayers();
        // small delay then reload same channel
        setTimeout(()=> { playChannel(ch); }, 1000);
      } catch(e){
        log('Reconnect error', e);
      }
      stuckCount = 0;
    }
  }, 1000);
}

/* Error & network reconnect: attach generic events */
videoEl.addEventListener('error', (e) => {
  log('Video element error event', e);
});
videoEl.addEventListener('stalled', () => log('Video stalled'));
videoEl.addEventListener('waiting', () => log('Video waiting/buffering'));
videoEl.addEventListener('playing', () => log('Video playing'));

/* ============================
   Playlist loading & UI
   ============================ */
async function fetchPlaylist(url){
  log('Fetching playlist from', url);
  try {
    const res = await fetch(url, {cache: 'no-store'});
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const text = await res.text();
    const parsed = parseM3U(text);
    log('Parsed channels count', parsed.length);
    return parsed;
  } catch(err){
    log('Failed to fetch playlist:', err.message || err);
    return [];
  }
}

function renderChannelList(list){
  const container = document.getElementById('channelList');
  container.innerHTML = '';
  list.forEach((ch, idx) => {
    const el = document.createElement('div');
    el.className = 'channel';
    el.dataset.idx = idx;
    el.innerHTML = `<div style="flex:1">
      <div class="title">${escapeHtml(ch.name)}</div>
      <div class="muted small">${escapeHtml(ch.url)}</div>
    </div>`;
    el.onclick = () => playChannel(ch);
    container.appendChild(el);
  });
  document.getElementById('totalCount').textContent = list.length;
}

function escapeHtml(s){ return (s+'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

/* Search filter */
document.getElementById('search').addEventListener('input', (e)=>{
  const q = e.target.value.trim().toLowerCase();
  if (!q) { renderChannelList(channels); return; }
  const filtered = channels.filter(c => (c.name || '').toLowerCase().includes(q) || (c.url||'').toLowerCase().includes(q));
  renderChannelList(filtered);
});

/* Manual refresh */
document.getElementById('refreshBtn').addEventListener('click', loadAndRender);

/* Auto refresh toggle */
document.getElementById('autoRefreshToggle').addEventListener('click', ()=>{
  autoRefresh = !autoRefresh;
  document.getElementById('autoRefreshToggle').textContent = `Auto Refresh: ${autoRefresh ? 'ON' : 'OFF'}`;
  if (autoRefresh){
    // refresh every 3 minutes
    playlistAutoRefreshInterval = setInterval(loadAndRender, 3 * 60 * 1000);
  } else {
    clearInterval(playlistAutoRefreshInterval);
    playlistAutoRefreshInterval = null;
  }
});

/* ============================
   Load playlist and render
   ============================ */
async function loadAndRender(){
  channels = await fetchPlaylist(PLAYLIST_URL);
  renderChannelList(channels);
  log('Playlist loaded.');
}

/* ============================
   Init
   ============================ */
loadAndRender();

/* Auto-play first channel if present after load (optional) */
(function autoPlayFirstIfWanted(){
  const tryPlay = setInterval(()=>{
    if (channels && channels.length > 0){
      // don't auto-play on mobile to avoid autoplay blocks; only if user hasn't interacted
      if (!/Mobi|Android/i.test(navigator.userAgent)){
        playChannel(channels[0]);
      }
      clearInterval(tryPlay);
    }
  }, 800);
})();

/* ============================
   Cleanup on unload
   ============================ */
window.addEventListener('beforeunload', ()=> {
  destroyPlayers();
});
</script>
</body>
  </html>
