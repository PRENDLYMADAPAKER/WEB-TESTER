<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Clinician DTR - User Panel (with Monopoly)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
  :root{
    --bg1:#fff0fb; --bg2:#f3e8ff; --accent:#7c3aed; --muted:#6b7280;
    --card-bg: rgba(255,255,255,0.18); --glass: rgba(255,255,255,0.18);
    --p-color: #2c0a34;
  }
  html,body{height:100%; margin:0; font-family:Inter,system-ui,Arial,sans-serif; background:linear-gradient(180deg,var(--bg1),#ffd6ed); color:var(--p-color);}
  .wrap{max-width:1024px;margin:18px auto;padding:18px;box-sizing:border-box;}
  .card{background:var(--card-bg);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);border-radius:16px;padding:18px;border:1px solid rgba(255,255,255,0.35);box-shadow:0 8px 30px rgba(12,12,20,0.06);margin-bottom:16px;}
  h1{margin:0 0 8px;font-size:20px}
  input,select,textarea{width:100%;box-sizing:border-box;padding:10px;border-radius:10px;border:1px solid rgba(255,255,255,0.4);background:rgba(255,255,255,0.14);color:var(--p-color);margin:6px 0}
  button{cursor:pointer;border:none;padding:10px 12px;border-radius:10px;background:linear-gradient(135deg,#fff,#ffd6fb,#c4b5fd);font-weight:600}
  .linkbtn{background:transparent;border:none;text-decoration:underline;cursor:pointer;color:var(--p-color)}
  .muted{color:var(--muted);font-size:13px}
  .small{padding:8px 10px;border-radius:8px}
  .row{display:flex;gap:12px;align-items:center}
  .col{flex:1}
  /* Toggle buttons */
  .toggle-btns{display:flex;gap:10px;margin:14px 0;flex-wrap:wrap}
  .toggle-btns button{background:transparent;border:1px solid rgba(0,0,0,0.06);padding:8px 12px;border-radius:12px}
  .toggle-btns button.active{background:var(--accent);color:white}
  /* Game area */
  .game-wrap{display:flex;gap:12px;flex-direction:row}
  @media(max-width:880px){ .game-wrap{flex-direction:column} }
  .left-col{flex:0 0 360px;min-width:280px}
  .right-col{flex:1;min-width:200px}
  .players-list{display:flex;flex-direction:column;gap:8px;margin-top:8px}
  .player-card{padding:10px;border-radius:10px;background:rgba(255,255,255,0.06);display:flex;align-items:center;gap:10px;justify-content:space-between;border:1px solid rgba(0,0,0,0.03)}
  .you{outline:2px solid #111827;border-radius:10px}
  .room-controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .room-code{font-weight:700;padding:6px 10px;border-radius:8px;background:rgba(0,0,0,0.06)}
  .dice{font-weight:800;padding:8px 12px;border-radius:10px;background:rgba(255,255,255,0.14);display:inline-block;min-width:62px;text-align:center}
  /* Board */
  .board-wrap{background:rgba(255,255,255,0.04);padding:10px;border-radius:12px}
  .board{display:grid;grid-template-columns:repeat(11,1fr);gap:6px}
  .space{min-height:62px;border-radius:8px;background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.02));display:flex;flex-direction:column;justify-content:space-between;padding:6px;font-size:11px;position:relative}
  .corner{min-height:88px}
  .prop-color{height:8px;width:100%;border-radius:6px;margin-bottom:6px}
  .tokens{position:absolute;right:6px;bottom:6px;display:flex;gap:4px;flex-wrap:wrap}
  .token{width:18px;height:18px;border-radius:50%;display:inline-block;border:2px solid #fff;box-shadow:0 2px 6px rgba(0,0,0,0.12)}
  /* popup */
  .popup{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:9999;background:white;padding:14px;border-radius:12px;box-shadow:0 18px 50px rgba(0,0,0,0.35);min-width:260px;display:none}
  .popup.show{display:block}
  .popup h3{margin:0 0 8px}
  .chat{max-height:180px;overflow:auto;background:rgba(255,255,255,0.03);padding:8px;border-radius:8px}
  .chat-line{padding:6px;border-radius:6px;margin-bottom:6px;background:rgba(0,0,0,0.03)}
  .log{max-height:160px;overflow:auto;background:rgba(255,255,255,0.03);padding:8px;border-radius:8px}
  .muted-small{font-size:12px;color:var(--muted)}
  .btn-danger{background:#ef4444;color:white}
  .controls-top{display:flex;gap:8px;align-items:center}
  /* responsive tweaks for mobile board size */
  @media(max-width:520px){
    .board{grid-template-columns:repeat(7,1fr)}
    .left-col{flex-basis:100%}
  }
  </style>
</head>
<body>
  <div class="wrap">
    <!-- === LOGIN / PANEL (preserved) === -->
    <div class="card" id="authArea">
      <h1>Login</h1>
      <input type="email" id="email" placeholder="Email" />
      <input type="password" id="password" placeholder="Password" />
      <button onclick="login()">Login</button>
      <p class="muted">Don‚Äôt have an account?
        <button class="linkbtn" onclick="toggleAuth('register')">Create one</button>
      </p>
      <p><button class="linkbtn" onclick="showForgotPassword()">Forgot Password?</button></p>
      <p id="authMsg" class="muted"></p>
    </div>

    <div class="card" id="forgotArea" style="display:none">
      <h1>Reset Password</h1>
      <input type="email" id="resetEmail" placeholder="Enter your registered email" />
      <button onclick="resetPassword()">Send Reset Link</button>
      <p class="muted"><button class="linkbtn" onclick="toggleAuth('login')">Back to Login</button></p>
      <p id="resetMsg" class="muted"></p>
    </div>

    <div class="card" id="registerArea" style="display:none">
      <h1>Create Account</h1>
      <input type="text" id="regName" placeholder="Full Name" />
      <input type="email" id="regEmail" placeholder="Email" />
      <input type="password" id="regPassword" placeholder="Password" />
      <input type="text" id="regLevel" placeholder="Clinical Level" />
      <button onclick="register()">Register</button>
      <p class="muted">Already have an account?
        <button class="linkbtn" onclick="toggleAuth('login')">Login</button>
      </p>
      <p id="regMsg" class="muted"></p>
    </div>

    <div class="card" id="userPanel" style="display:none">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <h1>DMD CLINICIAN DTR</h1>
        <div>
          <button id="settingsBtn" style="padding:6px 10px;font-size:13px;">‚öôÔ∏è Update Info</button>
        </div>
      </div>

      <div class="muted">Signed in as</div>
      <div id="nameDisplay" style="font-weight:600"></div>
      <div id="emailDisplay" class="muted"></div>
      <div id="levelDisplay" class="muted"></div>

      <div id="qr" style="margin:8px 0"></div>
      <div style="display:flex;gap:8px;align-items:center">
        <button id="logoutBtn" style="background:#ef4444;color:white;">Logout</button>
      </div>

      <div class="toggle-btns">
        <button id="dtrBtn" class="active">My DTR Records</button>
        <button id="caseBtn">My Case Selections</button>
        <button id="gameBtn">üé≤ Monopoly Game</button>
      </div>

      <div id="dtrSection">
        <h3>My DTR Records</h3>
        <table style="width:100%;border-collapse:collapse">
          <thead><tr><th style="text-align:left">Date</th><th style="text-align:left">Time In</th></tr></thead>
          <tbody id="myDtrBody"><tr><td colspan="2" class="muted">No records</td></tr></tbody>
        </table>
      </div>

      <div id="caseSection" style="display:none">
        <h3>My Case Selections</h3>
        <input type="text" id="caseSearch" class="search-box" placeholder="Search cases..." />
        <button id="openCaseModal" style="margin:6px 0" disabled title="Please Time In first">‚ûï New Case Selection</button>
        <table style="width:100%;border-collapse:collapse">
          <thead><tr><th>Type</th><th>Details</th><th>Date</th><th>Status</th><th>Action</th></tr></thead>
          <tbody id="caseBody"><tr><td colspan="5" class="muted">No cases</td></tr></tbody>
        </table>
      </div>

      <!-- MONOPOLY GAME SECTION -->
      <div id="gameSection" style="display:none">
        <h3>üé≤ Monopoly (Full Multiplayer)</h3>
        <div class="card game-wrap">
          <!-- Left: Controls & Players -->
          <div class="left-col">
            <div class="controls-top" style="justify-content:space-between">
              <div style="flex:1">
                <input id="roomInput" placeholder="Enter room code (or leave blank to create)" />
              </div>
              <div style="display:flex;gap:8px">
                <button id="createRoomBtn" class="small" onclick="createGameRoom()">Create Room</button>
                <button id="joinRoomBtn" class="small" onclick="joinGameRoom()">Join Room</button>
              </div>
            </div>

            <div style="display:flex;align-items:center;gap:8px;margin-top:8px">
              <div class="muted">Room:</div><div id="currentRoom" class="room-code">‚Äî</div>
              <div style="margin-left:auto" class="muted-small">Players: <span id="playerCount">0</span>/6</div>
            </div>

            <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px">
              <strong>Players</strong>
              <div>
                <button id="startGameBtn" class="small" onclick="startGame()" disabled>Start Game</button>
                <button id="leaveRoomBtn" class="small btn-danger" onclick="leaveRoom()">Leave</button>
              </div>
            </div>

            <div id="playersContainer" class="players-list" style="margin-top:8px"></div>

            <div class="room-controls">
              <div>You: <span id="youLabel" class="muted-small">‚Äî</span></div>
              <div>Turn: <span id="turnLabel" class="muted-small">‚Äî</span></div>
              <div>Dice: <span id="diceLabel" class="dice">‚Äî</span></div>
            </div>

            <div style="margin-top:8px;display:flex;gap:8px">
              <button id="rollBtn" class="small" onclick="rollDice()" disabled>Roll Dice</button>
              <button id="endTurnBtn" class="small" onclick="endTurn()" disabled>End Turn</button>
            </div>

            <div style="margin-top:12px">
              <strong>Room Log</strong>
              <div id="roomLog" class="log" style="margin-top:6px"></div>
            </div>

            <div style="margin-top:12px">
              <strong>Chat</strong>
              <div id="chatBox" class="chat" style="margin-top:6px"></div>
              <div style="display:flex;gap:8px;margin-top:6px">
                <input id="chatInput" placeholder="Type a message..." />
                <button onclick="sendChat()" class="small">Send</button>
              </div>
            </div>
          </div>

          <!-- Right: Board -->
          <div class="right-col">
            <div class="board-wrap">
              <div id="board" class="board"></div>
            </div>
          </div>
        </div>
      </div>

    </div> <!-- userPanel -->
  </div>

  <!-- SETTINGS & CASE & POPUPS (kept) -->
  <div id="settingsModal" class="popup">
    <button onclick="document.getElementById('settingsModal').classList.remove('show')" style="float:right;background:#ef4444;color:white;border:none;padding:6px 8px;border-radius:8px">‚úñ</button>
    <h3>Request Update</h3>
    <label>Field:
      <select id="fieldSelect">
        <option value="name">Name</option>
        <option value="email">Email</option>
        <option value="password">Password</option>
        <option value="clinicalLevel">Clinical Level</option>
      </select>
    </label>
    <input type="text" id="newValue" placeholder="Enter new value" />
    <button onclick="submitUpdate()">Submit Request</button>
    <p id="updateStatus" class="muted"></p>
  </div>

  <div id="buyPopup" class="popup">
    <h3 id="buyTitle">Buy Property</h3>
    <div id="buyBody" class="muted-small"></div>
    <div style="margin-top:10px;display:flex;gap:8px">
      <button onclick="confirmBuy()">Buy</button>
      <button onclick="closeBuy()" class="small btn-danger">Cancel</button>
    </div>
  </div>

  <div id="rentPopup" class="popup">
    <h3 id="rentTitle">Pay Rent</h3>
    <div id="rentBody" class="muted-small"></div>
    <div style="margin-top:10px;display:flex;gap:8px">
      <button onclick="confirmPayRent()">Pay Rent</button>
      <button onclick="closeRent()" class="small btn-danger">Cancel</button>
    </div>
  </div>

  <!-- CASE MODAL (kept) -->
  <div id="caseModal" class="popup" style="min-width:400px">
    <button onclick="document.getElementById('caseModal').classList.remove('show')" style="float:right;background:#ef4444;color:white;border:none;padding:6px 8px;border-radius:8px">‚úñ</button>
    <h3>Case Selection</h3>
    <div style="max-height:60vh;overflow:auto">
      <!-- same contents as before -->
      <div style="margin-top:8px">
        <div class="tab-buttons">
          <button class="tabBtn active" data-tab="livePatient">Live Patient</button>
          <button class="tabBtn" data-tab="typodonts">Typodonts</button>
          <button class="tabBtn" data-tab="cast">CAST</button>
        </div>

        <div id="livePatient" class="tab-section active" style="margin-top:8px">
          <label>Clinician Name</label>
          <input type="text" id="lpClinician" disabled />
          <label>Patient Name</label>
          <input type="text" id="lpPatient" />
          <label>Case Procedure</label>
          <input type="text" id="lpProcedure" />
          <label>Mastercard No. (optional)</label>
          <input type="text" id="lpMaster" />
        </div>

        <div id="typodonts" class="tab-section" style="display:none;margin-top:8px">
          <label>Case Type</label>
          <select id="typoCaseType">
            <option value="">-- Select --</option>
            <option value="pfm">PFM/FPD</option>
            <option value="restorative">Restorative</option>
          </select>
          <div id="pfmFields" style="display:none; margin-top:10px;">
            <label>PFM/FPD</label>
            <select id="typoPfm">
              <option value="">-- Select --</option>
              <option>Anterior</option>
              <option>Posterior</option>
            </select>
            <label>Mastercard No. (optional)</label>
            <input type="text" id="typoMasterPfm" />
          </div>
          <div id="restFields" style="display:none; margin-top:10px;">
            <label>Restorative (type manually)</label>
            <input type="text" id="typoRest" />
            <label>Mastercard No. (optional)</label>
            <input type="text" id="typoMasterRest" />
          </div>
        </div>

        <div id="cast" class="tab-section" style="display:none;margin-top:8px">
          <label>RPD or CD</label>
          <select id="castType">
            <option value="">-- Select --</option>
            <option>RPD</option>
            <option>CD</option>
          </select>
          <label>Mastercard No. (optional)</label>
          <input type="text" id="castMaster" />
        </div>
      </div>

      <div style="margin-top:12px">
        <button onclick="submitCase()">Submit Case</button>
        <p id="caseStatus" class="muted"></p>
      </div>
    </div>
  </div>
  <!-- SCRIPTS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.0.1/firebase-database-compat.js"></script>

  <script>
  // ---------- Firebase init (unchanged) ----------
  const firebaseConfig = {
    apiKey: "AIzaSyBYYZrsZECXM2UpW4-38sGQLaPqAqkjSWI",
    authDomain: "dtr-project-66048.firebaseapp.com",
    databaseURL: "https://dtr-project-66048-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "dtr-project-66048",
    storageBucket: "dtr-project-66048.appspot.com",
    messagingSenderId: "271445506225",
    appId: "1:271445506225:web:fcb04d0454e1302de14a90"
  };
  firebase.initializeApp(firebaseConfig);
  const auth = firebase.auth();
  const db = firebase.database();

  // ---------- BASIC AUTH UI (same as before) ----------
  function toggleAuth(mode){ document.getElementById("authArea").style.display = (mode==='register')?'none':'block'; document.getElementById("registerArea").style.display=(mode==='register')?'block':'none'; document.getElementById("forgotArea").style.display='none';}
  function showForgotPassword(){ document.getElementById('authArea').style.display='none'; document.getElementById('registerArea').style.display='none'; document.getElementById('forgotArea').style.display='block'; }
  async function resetPassword(){ const email=document.getElementById('resetEmail').value.trim(); const msg=document.getElementById('resetMsg'); if(!email){msg.textContent='Please enter your email.';msg.className='error'; return;} try{ await auth.sendPasswordResetEmail(email); msg.textContent='‚úÖ Password reset link sent!'; msg.className='success'; }catch(e){ msg.textContent=e.message; msg.className='error'; } }
  async function login(){ const email=document.getElementById('email').value; const pass=document.getElementById('password').value; const msg=document.getElementById('authMsg'); try{ await auth.signInWithEmailAndPassword(email,pass);}catch(e){ msg.textContent=e.message; msg.className='error'; }}
  async function register(){ const name=document.getElementById('regName').value.trim(); const email=document.getElementById('regEmail').value.trim(); const pass=document.getElementById('regPassword').value; const level=document.getElementById('regLevel').value.trim(); const msg=document.getElementById('regMsg'); try{ const cred = await auth.createUserWithEmailAndPassword(email, pass); const uid = cred.user.uid; await db.ref('users/' + uid + '/profile').set({ name, email, clinicalLevel: level }); msg.textContent='Account created! Redirecting...'; msg.className='success'; await auth.signInWithEmailAndPassword(email, pass);}catch(e){ msg.textContent=e.message; msg.className='error'; } }
  document.getElementById('logoutBtn').onclick = () => { leaveRoom(); auth.signOut(); };

  // === Load DTR & Cases (kept) ===
  async function loadUserDTR(uid){ const tbody=document.getElementById('myDtrBody'); const snap=await db.ref('users/'+uid+'/dtr').get(); tbody.innerHTML=''; if(!snap.exists()){ tbody.innerHTML="<tr><td colspan='2' class='muted'>No records</td></tr>"; return;} snap.forEach(child=>{ const date=child.key; const rec=child.val(); tbody.innerHTML+=`<tr><td>${date}</td><td>${rec.timeIn||'-'}</td></tr>`; }); }
  async function loadUserCases(uid){
    const tbody=document.getElementById('caseBody'); tbody.innerHTML="<tr><td colspan='5' class='muted'>Loading cases...</td></tr>";
    if(window.userCasesListener){ db.ref('userCases/'+uid).off('value', window.userCasesListener); }
    window.userCasesListener = db.ref('userCases/'+uid).on('value', snap=>{
      tbody.innerHTML=''; const seen=new Set();
      if(!snap.exists()){ tbody.innerHTML="<tr><td colspan='5' class='muted'>No cases</td></tr>"; return;}
      snap.forEach(child=>{ const cid=child.key; if(seen.has(cid)) return; seen.add(cid); const c=child.val()||{}; const date=c.timestamp?new Date(c.timestamp).toLocaleString():'-'; const status = c.status==='completed'?`<span class='status-badge completed'>‚úÖ Completed</span>`:`<span class='status-badge pending'>Pending</span>`; const action = c.status==='completed'?'‚Äî':`<button onclick="markCaseComplete('${uid}','${cid}', event)">Mark Completed</button>`; tbody.innerHTML+=`<tr id="case-${cid}"><td>${c.type||'-'}</td><td>${c.details||''}<br><span class='muted'>Instructor: ${c.instructor||"Pending"}</span></td><td>${date}</td><td>${status}</td><td>${action}</td></tr>`; });
      applyCaseSearch();
    });
  }
  function applyCaseSearch(){ const input=document.getElementById('caseSearch').value.toLowerCase(); const rows=document.querySelectorAll("#caseBody tr"); rows.forEach(row=>{ const text=row.innerText.toLowerCase(); row.style.display = text.includes(input)?'':'none'; }); }
  document.getElementById('caseSearch').addEventListener('input', applyCaseSearch);

  // mark complete (kept)
  let markInProgress=false;
  async function markCaseComplete(uid,cid,event){ if(markInProgress) return; markInProgress=true; try{ const btn=event?.target; if(btn){ btn.disabled=true; btn.innerText="‚è≥ Processing..."; } const caseRef=db.ref(`userCases/${uid}/${cid}`); const caseSnap=await caseRef.get(); if(!caseSnap.exists()){ showToast("‚ö†Ô∏è Case not found","warning"); return; } await caseRef.update({ status:"completed", completedAt: Date.now() }); showToast("‚úÖ Case marked as completed (user only)","success"); }catch(e){ console.error(e); showToast("‚ùå Failed to mark complete","error"); } finally{ const btn=event?.target; if(btn){ btn.disabled=false; btn.innerText="Mark Completed"; } markInProgress=false; } }

  // === Auth listener + set currentUser ===
  auth.onAuthStateChanged(async user=>{
    if(user){ document.getElementById('authArea').style.display='none'; document.getElementById('registerArea').style.display='none'; document.getElementById('forgotArea').style.display='none'; document.getElementById('userPanel').style.display='block';
      const profileSnap = await db.ref('users/'+user.uid+'/profile').get(); const profile = profileSnap.exists()?profileSnap.val():{};
      document.getElementById('nameDisplay').textContent = profile.name || user.email;
      document.getElementById('emailDisplay').textContent = profile.email || '';
      document.getElementById('levelDisplay').textContent = profile.clinicalLevel?`Clinical Level: ${profile.clinicalLevel}`:'';
      document.getElementById('lpClinician').value = profile.name || user.email;
      const qrDiv=document.getElementById('qr'); qrDiv.innerHTML=''; new QRCode(qrDiv,{text:user.uid,width:160,height:160});
      const today=new Date().toISOString().slice(0,10); const caseBtn=document.getElementById('openCaseModal');
      db.ref('users/'+user.uid+'/dtr/'+today).on('value', snap=>{ if(snap.exists() && snap.val().timeIn){ caseBtn.disabled=false; caseBtn.style.opacity='1'; caseBtn.style.cursor='pointer'; caseBtn.title='Add a new case'; } else { caseBtn.disabled=true; caseBtn.style.opacity='0.5'; caseBtn.style.cursor='not-allowed'; caseBtn.title='Please Time In first'; } });
      loadUserDTR(user.uid); loadUserCases(user.uid);
      window.currentUser = { uid:user.uid, email:user.email, name: profile.name || user.email };
    } else {
      document.getElementById('authArea').style.display='block'; document.getElementById('registerArea').style.display='none'; document.getElementById('forgotArea').style.display='none'; document.getElementById('userPanel').style.display='none';
      window.currentUser = null; leaveRoom();
    }
  });

  // === Settings & Case modal open/close (kept) ===
  document.getElementById('settingsBtn').onclick = ()=> document.getElementById('settingsModal').classList.add('show');
  document.getElementById('openCaseModal').onclick = ()=> document.getElementById('caseModal').classList.add('show');

  async function submitUpdate(){ const field=document.getElementById('fieldSelect').value; const value=document.getElementById('newValue').value.trim(); const status=document.getElementById('updateStatus'); const user=auth.currentUser; if(!user) return; if(!value){ status.textContent='Please enter a value.'; status.className='error'; return;} const reqRef=db.ref('updateRequests/'+user.uid).push(); await reqRef.set({ field, value, status:'pending', timestamp:Date.now() }); status.textContent='Request submitted.'; status.className='success'; document.getElementById('newValue').value=''; }

  // CASE tab logic (kept)
  document.querySelectorAll('.tabBtn').forEach(btn=>{ btn.onclick=()=>{ document.querySelectorAll('.tabBtn').forEach(b=>b.classList.remove('active')); btn.classList.add('active'); document.querySelectorAll('.tab-section').forEach(sec=>sec.classList.remove('active')); document.getElementById(btn.dataset.tab).classList.add('active'); }; });
  const typoCaseType=document.getElementById('typoCaseType'); const pfmFields=document.getElementById('pfmFields'); const restFields=document.getElementById('restFields');
  if(typoCaseType) typoCaseType.onchange = ()=> { if(typoCaseType.value==='pfm'){ pfmFields.style.display='block'; restFields.style.display='none'; } else if(typoCaseType.value==='restorative'){ restFields.style.display='block'; pfmFields.style.display='none'; } else { pfmFields.style.display='none'; restFields.style.display='none'; } };

  async function submitCase(){ const user=auth.currentUser; if(!user) return; const status=document.getElementById('caseStatus'); let caseData={ type:'', details:'', instructor:'Pending', timestamp:Date.now(), status:'pending' }; const activeTab = document.querySelector('.tabBtn.active').dataset.tab;
    if(activeTab==='livePatient'){ caseData.type='Live Patient'; caseData.details=`Patient: ${document.getElementById('lpPatient').value}, Procedure: ${document.getElementById('lpProcedure').value}, Mastercard: ${document.getElementById('lpMaster').value || "N/A"}`; }
    else if(activeTab==='typodonts'){ caseData.type='Typodonts'; if(typoCaseType.value==='pfm'){ caseData.details = `PFM/FPD: ${document.getElementById('typoPfm').value || "N/A"}, Mastercard: ${document.getElementById('typoMasterPfm').value || "N/A"}` } else if(typoCaseType.value==='restorative'){ caseData.details = `Restorative: ${document.getElementById('typoRest').value || "N/A"}, Mastercard: ${document.getElementById('typoMasterRest').value || "N/A"}` } else { status.textContent='Please select Typodonts case type.'; status.className='error'; return; } }
    else if(activeTab==='cast'){ caseData.type='CAST'; caseData.details=`Type: ${document.getElementById('castType').value || "N/A"}, Mastercard: ${document.getElementById('castMaster').value || "N/A"}`; }
    const caseRef = db.ref('cases/' + user.uid).push(); const caseId = caseRef.key;
    await caseRef.set(caseData); await db.ref(`userCases/${user.uid}/${caseId}`).set(caseData);
    status.textContent='Case submitted successfully!'; status.className='success';
    await loadUserCases(user.uid); setTimeout(()=>{ document.getElementById('caseModal').classList.remove('show'); status.textContent=''; },1000);
  }

  // SECTION toggles (kept)
  const dtrBtn=document.getElementById('dtrBtn'); const caseBtn=document.getElementById('caseBtn'); const gameBtn=document.getElementById('gameBtn');
  dtrBtn.onclick = ()=> { dtrBtn.classList.add('active'); caseBtn.classList.remove('active'); gameBtn.classList.remove('active'); document.getElementById('dtrSection').style.display='block'; document.getElementById('caseSection').style.display='none'; document.getElementById('gameSection').style.display='none'; };
  caseBtn.onclick = ()=> { caseBtn.classList.add('active'); dtrBtn.classList.remove('active'); gameBtn.classList.remove('active'); document.getElementById('caseSection').style.display='block'; document.getElementById('dtrSection').style.display='none'; document.getElementById('gameSection').style.display='none'; };
  gameBtn.onclick = ()=> { gameBtn.classList.add('active'); dtrBtn.classList.remove('active'); caseBtn.classList.remove('active'); document.getElementById('gameSection').style.display='block'; document.getElementById('dtrSection').style.display='none'; document.getElementById('caseSection').style.display='none'; initBoard(); refreshRoomUI(); }

  /**********************
   * Monopoly: Full Logic
   **********************/
  const BOARD_SIZE = 40;
  const MIN_PLAYERS = 4;
  const MAX_PLAYERS = 6;
  const CURRENCY = '‚Ç±';

  // property metadata (simple typical Monopoly-like but shortened)
  const PROPERTIES = [
    // index: 0..39
    { i:0, name:'GO', type:'corner' },
    { i:1, name:'Mediterranean Ave', price:60, rent:2, color:'#8b5cf6' },
    { i:2, name:'Community Chest', type:'card' },
    { i:3, name:'Baltic Ave', price:60, rent:4, color:'#8b5cf6' },
    { i:4, name:'Income Tax', type:'tax' },
    { i:5, name:'Reading RR', price:200, rent:25, color:'#666' },
    { i:6, name:'Oriental Ave', price:100, rent:6, color:'#60a5fa' },
    { i:7, name:'Chance', type:'card' },
    { i:8, name:'Vermont Ave', price:100, rent:6, color:'#60a5fa' },
    { i:9, name:'Connecticut Ave', price:120, rent:8, color:'#60a5fa' },
    { i:10, name:'Jail', type:'corner' },
    { i:11, name:'St. Charles Place', price:140, rent:10, color:'#fb7185' },
    { i:12, name:'Electric Company', price:150, rent:10, color:'#f59e0b' },
    { i:13, name:'States Ave', price:140, rent:10, color:'#fb7185' },
    { i:14, name:'Virginia Ave', price:160, rent:12, color:'#fb7185' },
    { i:15, name:'Pennsylvania RR', price:200, rent:25, color:'#666' },
    { i:16, name:'St. James Place', price:180, rent:14, color:'#f97316' },
    { i:17, name:'Community Chest', type:'card' },
    { i:18, name:'Tennessee Ave', price:180, rent:14, color:'#f97316' },
    { i:19, name:'New York Ave', price:200, rent:16, color:'#f97316' },
    { i:20, name:'Free Parking', type:'corner' },
    { i:21, name:'Kentucky Ave', price:220, rent:18, color:'#ef4444' },
    { i:22, name:'Chance', type:'card' },
    { i:23, name:'Indiana Ave', price:220, rent:18, color:'#ef4444' },
    { i:24, name:'Illinois Ave', price:240, rent:20, color:'#ef4444' },
    { i:25, name:'B. & O. RR', price:200, rent:25, color:'#666' },
    { i:26, name:'Atlantic Ave', price:260, rent:22, color:'#10b981' },
    { i:27, name:'Ventnor Ave', price:260, rent:22, color:'#10b981' },
    { i:28, name:'Water Works', price:150, rent:10, color:'#f59e0b' },
    { i:29, name:'Marvin Gardens', price:280, rent:24, color:'#10b981' },
    { i:30, name:'Go To Jail', type:'corner' },
    { i:31, name:'Pacific Ave', price:300, rent:26, color:'#06b6d4' },
    { i:32, name:'North Carolina Ave', price:300, rent:26, color:'#06b6d4' },
    { i:33, name:'Community Chest', type:'card' },
    { i:34, name:'Pennsylvania Ave', price:320, rent:28, color:'#06b6d4' },
    { i:35, name:'Short Line', price:200, rent:25, color:'#666' },
    { i:36, name:'Chance', type:'card' },
    { i:37, name:'Park Place', price:350, rent:35, color:'#111827' },
    { i:38, name:'Luxury Tax', type:'tax' },
    { i:39, name:'Boardwalk', price:400, rent:50, color:'#111827' }
  ];

  // helper: get property by index
  function getProperty(i){ return PROPERTIES.find(p=>p.i===i) || { i:i, name:`Space ${i}` }; }

  // game state local
  window.gameState = { roomId:null, roomRef:null, unsubscribe:null, localPlayerId:null, colors:['#ef4444','#06b6d4','#f59e0b','#10b981','#7c3aed','#e11d48'], tokenIcons:['üöó','üé©','üè†','üíé','üê∂','üö≤'] };

  // Logging helper
  function logRoom(msg){ const el=document.getElementById('roomLog'); const line = document.createElement('div'); line.textContent = `${new Date().toLocaleTimeString()} ‚Äî ${msg}`; el.prepend(line); }

  // ---------- board UI generation ----------
  function initBoard(){
    const boardEl=document.getElementById('board'); boardEl.innerHTML='';
    // create 40 spaces in a grid that visually approximates the perimeter
    for(let i=0;i<40;i++){
      const p = getProperty(i);
      const div = document.createElement('div');
      div.className = 'space' + (p.type==='corner'?' corner':'');
      div.id = 'space-' + i;
      // color strip for properties
      const colorStrip = document.createElement('div'); colorStrip.className='prop-color';
      colorStrip.style.background = p.color || 'transparent';
      if(!p.price) colorStrip.style.opacity = 0.25;
      const nameDiv = document.createElement('div');
      nameDiv.innerHTML = `<div style="font-weight:700;font-size:12px">${p.name}</div><div style="font-size:11px;color:var(--muted)">${p.price?CURRENCY + p.price:''}</div>`;
      const tokenWrap = document.createElement('div'); tokenWrap.className='tokens'; tokenWrap.id = 'tokens-'+i;
      div.appendChild(colorStrip); div.appendChild(nameDiv); div.appendChild(tokenWrap);
      boardEl.appendChild(div);
    }
  }

  // ---------- Room management ----------
  function genRoomCode(){ const chars='ABCDEFGHJKMNPQRSTUVWXYZ23456789'; let s=''; for(let i=0;i<6;i++) s+=chars[Math.floor(Math.random()*chars.length)]; return s; }

  // create room
  async function createGameRoom(){
    if(!window.currentUser){ alert('Please login'); return; }
    const code = genRoomCode();
    const roomRef = db.ref('monopolyRooms/' + code);
    const snap = await roomRef.get();
    if(snap.exists()) return createGameRoom(); // collision guard
    const player = { id:window.currentUser.uid, name:window.currentUser.name || window.currentUser.email, pos:0, money:1500, joinedAt:Date.now(), color: window.gameState.colors[0], token: window.gameState.tokenIcons[0], online:true };
    await roomRef.set({ owner: window.currentUser.uid, createdAt:Date.now(), players:{ [window.currentUser.uid]:player }, turnOrder:[window.currentUser.uid], currentTurnIndex:0, started:false, lastActionAt:Date.now(), chat:{}, heartbeat:Date.now() });
    window.gameState.roomId = code; window.gameState.roomRef = roomRef;
    attachRoomListener(code);
    document.getElementById('roomInput').value = code; document.getElementById('currentRoom').textContent = code;
    logRoom('Room created ‚Äî code: ' + code);
    refreshRoomUI();
    // mark presence
    markPresence(code, true);
  }

  // join room
  async function joinGameRoom(){
    if(!window.currentUser){ alert('Please login'); return; }
    const code = document.getElementById('roomInput').value.trim().toUpperCase();
    if(!code){ alert('Enter room code or create one'); return; }
    const roomRef = db.ref('monopolyRooms/' + code);
    const snap = await roomRef.get();
    if(!snap.exists()) return alert('Room not found');
    const room = snap.val();
    const players = room.players || {};
    const count = Object.keys(players).length;
    if(count >= MAX_PLAYERS) return alert('Room is full (max 6 players)');
    // if already in room, just attach
    if(players[window.currentUser.uid]){
      window.gameState.roomId = code; window.gameState.roomRef = roomRef;
      attachRoomListener(code); document.getElementById('currentRoom').textContent = code; logRoom('Rejoined room: ' + code); markPresence(code,true); refreshRoomUI(); return;
    }
    // assign color/token
    const idx = count % window.gameState.colors.length;
    const player = { id:window.currentUser.uid, name:window.currentUser.name || window.currentUser.email, pos:0, money:1500, joinedAt:Date.now(), color: window.gameState.colors[idx], token: window.gameState.tokenIcons[idx], online:true };
    await roomRef.child('players/' + window.currentUser.uid).set(player);
      // update turn order
    const order = room.turnOrder || []; if(!order.includes(window.currentUser.uid)) order.push(window.currentUser.uid);
    await roomRef.child('turnOrder').set(order);
    window.gameState.roomId = code; window.gameState.roomRef = roomRef;
    attachRoomListener(code); document.getElementById('currentRoom').textContent = code; logRoom('Joined room: ' + code); markPresence(code,true); refreshRoomUI();
  }

  // leave room
  async function leaveRoom(){
    try{
      const gid = window.gameState.roomId;
      if(!gid) return;
      const roomRef = db.ref('monopolyRooms/' + gid);
      // mark offline
      if(window.currentUser){
        await roomRef.child('players/' + window.currentUser.uid + '/online').set(false);
        await roomRef.child('players/' + window.currentUser.uid + '/lastSeen').set(Date.now());
        // remove player node from turnOrder and players
        const tSnap = await roomRef.child('turnOrder').get();
        if(tSnap.exists()){
          const order = tSnap.val().filter(id => id !== window.currentUser.uid);
          await roomRef.child('turnOrder').set(order);
        }
        // remove player entry
        await roomRef.child('players/' + window.currentUser.uid).remove();
      }
      // if owner left, transfer or remove room
      const ownerSnap = await roomRef.child('owner').get();
      if(ownerSnap.exists() && ownerSnap.val() === (window.currentUser && window.currentUser.uid)){
        const playersSnap = await roomRef.child('players').get();
        if(playersSnap.exists()){
          const keys = Object.keys(playersSnap.val());
          if(keys.length > 0){
            await roomRef.child('owner').set(keys[0]);
          } else {
            await roomRef.remove();
          }
        } else {
          await roomRef.remove();
        }
      }
      // detach listener
      if(window.gameState.unsubscribe){ window.gameState.unsubscribe(); window.gameState.unsubscribe = null; }
      window.gameState.roomId = null; window.gameState.roomRef = null;
      document.getElementById('currentRoom').textContent = '‚Äî'; document.getElementById('playersContainer').innerHTML=''; document.getElementById('roomLog').innerHTML=''; document.getElementById('diceLabel').textContent='‚Äî'; document.getElementById('turnLabel').textContent='‚Äî'; document.getElementById('youLabel').textContent='‚Äî'; refreshRoomUI();
    }catch(e){ console.error('leaveRoom error', e); }
  }

  // attach listener
  function attachRoomListener(roomId){
    if(window.gameState.unsubscribe) window.gameState.unsubscribe();
    const rRef = db.ref('monopolyRooms/' + roomId);
    const callback = rRef.on('value', snap=>{
      if(!snap.exists()){ logRoom('Room closed.'); leaveRoom(); return; }
      const room = snap.val();
      renderRoom(room);
      // auto-cleanup: set heartbeat
      rRef.child('heartbeat').set(Date.now());
    }, err=>{ console.error('room listen error', err); });
    window.gameState.unsubscribe = ()=> rRef.off('value', callback);
    window.gameState.roomRef = rRef;
  }

  // presence ‚Äî mark online (reconnection helps)
  function markPresence(roomId, online=true){
    if(!window.currentUser) return;
    const pRef = db.ref(`monopolyRooms/${roomId}/players/${window.currentUser.uid}`);
    pRef.update({ online: online, lastSeen: Date.now() });
    // if disconnect unexpectedly, set offline via onDisconnect
    pRef.onDisconnect().update({ online:false, lastSeen:Date.now() });
  }

  // ---------- render room UI ----------
  function renderRoom(room){
    if(!room) return;
    const players = room.players || {};
    const pc = document.getElementById('playersContainer'); pc.innerHTML='';
    const order = room.turnOrder || [];
    // order players by join order (turnOrder)
    order.forEach(pid=>{
      const p = players[pid];
      if(!p) return;
      const div = document.createElement('div'); div.className = 'player-card' + (pid === (window.currentUser && window.currentUser.uid)?' you':'');
      div.innerHTML = `<div style="display:flex;gap:10px;align-items:center"><div style="width:18px;height:18px;border-radius:50%;background:${p.color||'#999'};display:flex;align-items:center;justify-content:center;color:white;font-size:12px">${p.token||'‚óè'}</div><div><strong>${p.name}</strong><div class="muted-small">${p.online? 'Online' : 'Offline'}</div></div></div><div style="text-align:right"><div class="muted-small">Pos: <span id="pos-${pid}">${p.pos||0}</span></div><div class="muted-small">Money: ${CURRENCY}<span id="money-${pid}">${p.money||0}</span></div></div>`;
      pc.appendChild(div);
    });
    document.getElementById('playerCount').textContent = Object.keys(players).length;

    // turn and dice
    const turnIndex = room.currentTurnIndex || 0;
    const currentTurnPlayer = (room.turnOrder || [])[turnIndex] || null;
    document.getElementById('turnLabel').textContent = currentTurnPlayer ? ((room.players && room.players[currentTurnPlayer] && room.players[currentTurnPlayer].name) || currentTurnPlayer) : '-';
    if(room.lastDice) { document.getElementById('diceLabel').textContent = `${room.lastDice[0]} + ${room.lastDice[1]} = ${room.lastDice[0]+room.lastDice[1]}`; } else { document.getElementById('diceLabel').textContent='‚Äî'; }
    // enable/disable controls
    if(window.currentUser && room.started && currentTurnPlayer === window.currentUser.uid){ document.getElementById('rollBtn').disabled=false; document.getElementById('endTurnBtn').disabled=false; } else { document.getElementById('rollBtn').disabled=true; document.getElementById('endTurnBtn').disabled=true; }
    // start game rules: only owner and at least MIN_PLAYERS needed
    if(window.currentUser && room.owner === window.currentUser.uid && !room.started && Object.keys(players).length >= MIN_PLAYERS){ document.getElementById('startGameBtn').disabled=false; } else { document.getElementById('startGameBtn').disabled=true; }

    // update room code on UI
    document.getElementById('currentRoom').textContent = window.gameState.roomId || '‚Äî';

    // log message if new events (simple)
    if(room._lastLog && room._lastLog !== window._lastLogSeen){ logRoom(room._lastLog); window._lastLogSeen = room._lastLog; }

    // update tokens on board
    updateBoardTokens(room);

    // chat render
    renderChat(room.chat || {});
  }

  // ---------- board tokens update ----------
  function updateBoardTokens(room){
    // clear tokens
    for(let i=0;i<BOARD_SIZE;i++){ const el = document.getElementById('tokens-'+i); if(el) el.innerHTML = ''; }
    const players = room.players || {};
    Object.keys(players).forEach(pid=>{
      const p = players[pid];
      const pos = p.pos || 0;
      const tokensEl = document.getElementById('tokens-'+pos);
      if(tokensEl){
        const span = document.createElement('div'); span.className='token'; span.style.background = p.color || '#999'; span.title = p.name; span.textContent = p.token || '';
        span.style.display='flex'; span.style.alignItems='center'; span.style.justifyContent='center'; span.style.fontSize='11px';
        tokensEl.appendChild(span);
      }
    });
  }

  // ---------- start game ----------
  async function startGame(){
    const gid = window.gameState.roomId; if(!gid) return alert('Join or create a room first');
    const roomRef = db.ref('monopolyRooms/' + gid); const snap = await roomRef.get(); if(!snap.exists()) return;
    const room = snap.val();
    if(room.owner !== window.currentUser.uid) return alert('Only owner can start');
    const players = room.players || {}; const count = Object.keys(players).length;
    if(count < MIN_PLAYERS) return alert(`At least ${MIN_PLAYERS} players required to start.`);
    // set started true, ensure turnOrder includes all players
    const order = room.turnOrder && room.turnOrder.length>0 ? room.turnOrder : Object.keys(players);
    await roomRef.update({ started:true, turnOrder: order, currentTurnIndex: 0, lastActionAt: Date.now(), _lastLog: 'Game started' });
    logRoom('Game started');
  }

  // ---------- roll dice ----------
  async function rollDice(){
    const gid = window.gameState.roomId; if(!gid) return;
    const roomRef = db.ref('monopolyRooms/' + gid); const snap = await roomRef.get(); if(!snap.exists()) return;
    const room = snap.val(); const turnIndex = room.currentTurnIndex || 0; const currentTurnPlayer = (room.turnOrder || [])[turnIndex];
    if(currentTurnPlayer !== window.currentUser.uid) return alert('Not your turn');
    // roll
    const d1 = Math.floor(Math.random()*6)+1; const d2 = Math.floor(Math.random()*6)+1; const total = d1 + d2;
    // compute new pos
    const player = (room.players && room.players[window.currentUser.uid]) || null;
    const newPos = ((player && player.pos) || 0) + total;
    const wrapped = newPos % BOARD_SIZE;
    const updates = {}; updates['players/' + window.currentUser.uid + '/pos'] = wrapped; updates['lastDice'] = [d1,d2]; updates['lastActionAt'] = Date.now(); updates['_lastLog'] = `${window.currentUser.name || window.currentUser.email} rolled ${d1} + ${d2} = ${total} and moved to ${wrapped}`;
    await roomRef.update(updates);
    // after moving, check landed property logic
    setTimeout(()=> checkLanding(gid, wrapped), 350); // slight delay for UX
  }

  // ---------- check landing: buy or pay rent ----------
  async function checkLanding(roomId, spaceIndex){
    const roomRef = db.ref('monopolyRooms/' + roomId); const snap = await roomRef.get(); if(!snap.exists()) return;
    const room = snap.val(); const p = getProperty(spaceIndex);
    const player = room.players && room.players[window.currentUser.uid];
    if(!player) return;
    // Pass GO? if pos increased beyond wrap, we gave money actually not tracked; simpler: when landing on GO (0) give reward
    if(spaceIndex === 0){
      // passing or landing GO reward
      const newMoney = (player.money || 0) + 200;
      await roomRef.child('players/' + window.currentUser.uid + '/money').set(newMoney);
      await roomRef.child('_lastLog').set(`${player.name} collected ${CURRENCY}200 for landing on GO`);
      return;
    }
    // taxes
    if(p.type === 'tax'){
      const tax = (p.name==='Income Tax')?200:100;
      const newMoney = (player.money || 0) - tax;
      await roomRef.child('players/' + window.currentUser.uid + '/money').set(newMoney);
      await roomRef.child('_lastLog').set(`${player.name} paid ${CURRENCY}${tax} (${p.name})`);
      return;
    }
    // cards (Chance/Community) implement simple random effect
    if(p.type === 'card'){
      const effect = Math.random() > 0.5 ? 'gain' : 'lose';
      const amount = Math.floor(Math.random()*150) + 20;
      const newMoney = effect === 'gain' ? (player.money || 0) + amount : (player.money || 0) - amount;
      await roomRef.child('players/' + window.currentUser.uid + '/money').set(newMoney);
      await roomRef.child('_lastLog').set(`${player.name} ${effect === 'gain' ? 'received' : 'lost'} ${CURRENCY}${amount} (${p.name})`);
      return;
    }
    // normal property: if purchasable
    if(p.price){
      // read owner info stored under room.propertiesOwners maybe; we'll attach owners under room.owners
      const ownersSnap = await roomRef.child('owners/' + spaceIndex).get();
      if(!ownersSnap.exists()){
        // unowned => offer buy popup only to the player who landed
        if(window.currentUser && room && room.players && room.players[window.currentUser.uid]){
          // show buy popup only for the player who landed
          if(window.currentUser.uid === (room && room.players && room.players[window.currentUser.uid] && window.currentUser.uid)){
            showBuyPopup(spaceIndex, p, roomId);
          }
        }
      } else {
        const ownerId = ownersSnap.val();
        if(ownerId !== window.currentUser.uid){
          // calculate rent and open pay rent popup for landing player
          const rent = p.rent || Math.max(10, Math.floor(p.price * 0.1));
          showRentPopup(spaceIndex, p, ownerId, rent, roomId);
        } else {
          // landed on own property ‚Äî nothing to do
        }
      }
    }
  }

  // ---------- Buy flow ----------
  let pendingBuy = null;
  function showBuyPopup(spaceIndex, property, roomId){
    pendingBuy = { spaceIndex, property, roomId };
    document.getElementById('buyTitle').textContent = `Buy ${property.name}?`;
    document.getElementById('buyBody').textContent = `${property.name} costs ${CURRENCY}${property.price}. Your balance: ${CURRENCY}${(window.currentUserMoney || 0) || 0}`;
    document.getElementById('buyPopup').classList.add('show');
  }
  function closeBuy(){ pendingBuy = null; document.getElementById('buyPopup').classList.remove('show'); }
  async function confirmBuy(){
    if(!pendingBuy) return closeBuy();
    const { spaceIndex, property, roomId } = pendingBuy;
    const roomRef = db.ref('monopolyRooms/' + roomId);
    const snap = await roomRef.get(); if(!snap.exists()) return closeBuy();
    const room = snap.val(); const player = room.players && room.players[window.currentUser.uid];
    if(!player) return closeBuy();
    const price = property.price;
    if((player.money || 0) < price){ alert('Insufficient funds'); closeBuy(); return; }
    // deduct money and set owner
    await roomRef.child('owners/' + spaceIndex).set(window.currentUser.uid);
    await roomRef.child('players/' + window.currentUser.uid + '/money').set((player.money || 0) - price);
    await roomRef.child('_lastLog').set(`${player.name} bought ${property.name} for ${CURRENCY}${price}`);
    closeBuy();
  }

  // ---------- Rent flow ----------
  let pendingRent = null;
  function showRentPopup(spaceIndex, property, ownerId, rent, roomId){
    pendingRent = { spaceIndex, property, ownerId, rent, roomId };
    const ownerName = document.getElementById('pos-' + ownerId) ? 'Player' : (ownerId || 'owner');
    document.getElementById('rentTitle').textContent = `Pay Rent to ${ownerId}`;
    document.getElementById('rentBody').textContent = `${property.name} owned by ${ownerId}. Rent: ${CURRENCY}${rent}. Your balance: ${CURRENCY}${(window.currentUserMoney || 0) || 0}`;
    document.getElementById('rentPopup').classList.add('show');
  }
  function closeRent(){ pendingRent = null; document.getElementById('rentPopup').classList.remove('show'); }
  async function confirmPayRent(){
    if(!pendingRent) return closeRent();
    const { ownerId, rent, roomId, property } = pendingRent;
    const roomRef = db.ref('monopolyRooms/' + roomId);
    const snap = await roomRef.get(); if(!snap.exists()) return closeRent();
    const room = snap.val();
    const payer = room.players && room.players[window.currentUser.uid];
    const owner = room.players && room.players[ownerId];
    if(!payer) return closeRent();
    // transfer money
    const payerNew = (payer.money || 0) - rent;
    await roomRef.child('players/' + window.currentUser.uid + '/money').set(payerNew);
    if(owner) await roomRef.child('players/' + ownerId + '/money').set((owner.money||0) + rent);
    await roomRef.child('_lastLog').set(`${payer.name} paid ${CURRENCY}${rent} rent for ${property.name} to ${owner ? owner.name : ownerId}`);
    closeRent();
  }

  // ---------- End Turn ----------
  async function endTurn(){
    const gid = window.gameState.roomId; if(!gid) return;
    const roomRef = db.ref('monopolyRooms/' + gid);
    const snap = await roomRef.get(); if(!snap.exists()) return;
    const room = snap.val(); const order = room.turnOrder || []; if(order.length === 0) return;
    const nextIndex = ((room.currentTurnIndex || 0) + 1) % order.length;
    await roomRef.update({ currentTurnIndex: nextIndex, lastActionAt: Date.now(), _lastLog: 'Turn passed to next player' });
    logRoom('Turn passed to next player');
  }

  // ---------- Chat ----------
  async function sendChat(){
    const gid = window.gameState.roomId; if(!gid) return;
    const text = document.getElementById('chatInput').value.trim(); if(!text) return;
    const chatRef = db.ref('monopolyRooms/'+gid+'/chat').push();
    await chatRef.set({ uid: window.currentUser.uid, name: window.currentUser.name, text, ts: Date.now() });
    document.getElementById('chatInput').value = '';
  }
  function renderChat(chatObj){
    const arr = Object.keys(chatObj||{}).map(k=> ({ id:k, ...chatObj[k] })).sort((a,b)=> b.ts - a.ts);
    const box = document.getElementById('chatBox'); box.innerHTML='';
    arr.forEach(c=>{
      const d = document.createElement('div'); d.className='chat-line'; d.innerHTML = `<strong>${c.name}</strong><div class="muted-small">${new Date(c.ts).toLocaleTimeString()}</div><div style="margin-top:6px">${c.text}</div>`; box.appendChild(d);
    });
  }

  // ---------- Board / Token helper on load ----------
  initBoard();

  // ---------- small heartbeat/cleanup: remove rooms empty > 5 minutes ----------
  setInterval(async ()=>{
    try{
      const roomsSnap = await db.ref('monopolyRooms').get();
      if(!roomsSnap.exists()) return;
      const now = Date.now();
      roomsSnap.forEach(roomSnap=>{
        const room = roomSnap.val(); const key = roomSnap.key;
        const players = room.players || {};
        if(Object.keys(players).length === 0){
          const last = room.heartbeat || room.lastActionAt || room.createdAt || 0;
          if(now - last > 1000 * 60 * 5){ // 5 minutes
            db.ref('monopolyRooms/' + key).remove().catch(()=>{});
          }
        }
      });
    }catch(e){}
  }, 60 * 1000); // every minute

  // ---------- presence reconnection: when auth state restored, rejoin previous room if any ----------
  // We will try to detect if user had a room in DB under players and auto-attach
  async function tryAutoRejoin(){
    if(!window.currentUser) return;
    const roomsSnap = await db.ref('monopolyRooms').get();
    if(!roomsSnap.exists()) return;
    const uid = window.currentUser.uid;
    let found = null;
    roomsSnap.forEach(rs=>{
      const r = rs.val();
      if(r.players && r.players[uid]) found = rs.key;
    });
    if(found){
      document.getElementById('roomInput').value = found;
      joinGameRoom();
    }
  }
  // call on login
  auth.onAuthStateChanged(user=>{
    if(user) setTimeout(tryAutoRejoin, 1500);
  });

  // ---------- refresh UI helper ----------
  function refreshRoomUI(){
    const gid = window.gameState.roomId;
    document.getElementById('startGameBtn').disabled = true;
    document.getElementById('rollBtn').disabled = true;
    document.getElementById('endTurnBtn').disabled = true;
    if(gid && window.currentUser){
      db.ref('monopolyRooms/' + gid).get().then(snap=>{
        if(!snap.exists()) return;
        const room = snap.val();
        if(room.owner === window.currentUser.uid && (!room.started || room.started === false) && Object.keys(room.players || {}).length >= MIN_PLAYERS) document.getElementById('startGameBtn').disabled = false;
        document.getElementById('youLabel').textContent = window.currentUser.name || window.currentUser.email;
      });
    }
  }

  // small toast
  function showToast(msg){ console.log('[toast]',msg); }

  // poll to update board tokens and room state occasionally (defensive)
  setInterval(()=>{
    if(window.gameState.roomId){
      db.ref('monopolyRooms/' + window.gameState.roomId).get().then(snap=>{ if(snap.exists()) renderRoom(snap.val()); }).catch(()=>{});
    }
  }, 3000);

  // small UI init
  document.addEventListener('DOMContentLoaded', ()=>{ initBoard(); });

  </script>

  <style>
    footer.page-footer{ text-align:center;width:100%;padding:10px 0;font-size:13px;color:#5a437c;opacity:0.85;margin-top:18px }
  </style>

  <footer class="page-footer">
    Created by <strong>NZM</strong><br>
    &copy; 2025 | To God Be the Glory
  </footer>
</body>
</html>
